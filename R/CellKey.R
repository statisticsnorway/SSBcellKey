
#' Converting tabular data by a perturbation table and uniformly distributed keys
#' 
#' The perturbation table is created by package ptable. 
#' 
#' With `freqVar=NULL` and `preAggregate = FALSE`, the calculated keys are returned.
#' 
#' @param data Input data as a data frame (inner cells)
#' @param freqVar Variable holding counts (name or number)
#' @param rKeyVar Variable holding uniformly distributed keys. When NULL, `keys` are generated by \code{\link{runif}}).
#' @param formula Model formula defining publishable cells. Will be used to calculate \code{x} (via \code{\link{ModelMatrix}}). 
#' @param hierarchies List of hierarchies, which can be converted by \code{\link{AutoHierarchies}}. 
#'        Thus, a single string as hierarchy input is assumed to be a total code. 
#'        Exceptions are \code{"rowFactor"} or \code{""}, which correspond to only using the categories in the data.
#' @param dimVar The main dimensional variables and additional aggregating variables. This parameter can be  useful when hierarchies and formula are unspecified. 
#' @param preAggregate When `TRUE`, the data will be aggregated within the function to an appropriate level. 
#' @param total	String used to name totals
#' @param x Dummy matrix defining cells to be published (possible as input instead of generated)
#' @param crossTable	Data frame to accompany `x` when `x` is input.  
#' @param xReturn	Dummy matrix in output when `TRUE` (as input parameter x)
#' @param k number of top contributors to be considered in relative noise
#' @param innerReturn	Input data in output when `TRUE` (possibly pre-aggregated). To return only inner data, use `innerReturn = 1`.   
#' @param D \code{\link{pt_create_pParams}} parameter
#' @param V \code{\link{pt_create_pParams}} parameter
#' @param js \code{\link{pt_create_pParams}} parameter
#' @param pstay \code{\link{pt_create_pParams}} parameter
#' @param rndSeed If non-NULL, a random generator seed to be used locally within the function without affecting the random value stream in R.
#'                This parameter applies when `rKeyVar` is not supplied.
#'
#' @return Data frame with keys or aggregated counts (original and perturbed). 
#'         A list when `xReturn` and/or `innerReturn` is `TRUE` (main output named as `"publish"`).
#' 
#' 
#' @importFrom SSBtools FindHierarchies ModelMatrix
#' @importFrom stats runif aggregate as.formula delete.response terms
#' @importFrom utils flush.console
#' @importFrom Matrix Matrix   
#' @export
#'
#' @examples
#' z <- data.frame(geo  = c("Iceland", "Portugal", "Spain"), 
#'                 eu = c("nonEU", "EU", "EU"),
#'                 year = rep(c("2018","2019"), each = 3),
#'                 freq = c(2,3,7,1,5,6), stringsAsFactors = FALSE)
#' 
#' CellKey(z, "freq", formula = ~eu * year + geo)
#' CellKey(z, freqVar = NULL, formula = ~eu * year + geo)
#' CellKey(z, freqVar = NULL, formula = ~eu * year + geo, preAggregate = FALSE)
#' z$keys <- sin(1:6)%%1
#' CellKey(z, "freq", "keys", formula = ~eu * year + geo)
#' CellKey(z, "freq", "keys", dimVar = c("geo", "eu", "year"))
#' CellKey(z, freqVar = NULL, "keys", dimVar = c("geo", "eu", "year"))
#' CellKey(z, "freq", "keys", hierarchies = 
#'      list(geo = c("EU", "@Portugal", "@Spain", "Iceland"), year = c("2018", "2019")))
#'
#' # my_km2 is temporary function, SSBtoolsData('my_km2') available in next SSBtools version
#' my_km2 <- SSBcellKey:::my_km2()
#' set.seed(123)
#' my_km2$keys <- runif(nrow(my_km2))
#' CellKey(my_km2, "freq", "keys", formula = ~(Sex + Age) * Municipality * Square1000m + Square250m)      
CellKey <- function(data, freqVar=NULL, rKeyVar=NULL, 
                    hierarchies = NULL, formula = NULL, dimVar = NULL, 
                    preAggregate = is.null(freqVar),
                    total = "Total", 
                    x = NULL, crossTable = NULL,
                    xReturn = FALSE, innerReturn = FALSE,
                    ddc.function = function(x) x,
                    flex.function = function(x) 1,
                    relativeNoise = FALSE,
                    k = 1,
                    m = rep(1, k),
                    noisefunction = NULL,
                    usePTable = FALSE,
                    D=5, V=3, js=2, pstay = NULL, rndSeed = 123, ...){

  force(preAggregate)
  
  names_data <- names(data)
    
  # Ensure character (integer possible input) 
  freqVar <- names(data[1, freqVar, drop = FALSE])
  
  if (is.null(formula) & is.null(hierarchies) & is.null(x) & is.null(dimVar)){
    dimVar <- names(data[1, !(names(data) %in% c(freqVar, rKeyVar)), drop = FALSE])
  } else {
    dimVar <- names(data[1, dimVar, drop = FALSE])
  }
  
  inner <- vector("list", 0)
  
  if (preAggregate | innerReturn){
    if (!is.null(hierarchies)) {
      dVar <- names(hierarchies)
    } else {
      if (!is.null(formula)) {
        dVar <- row.names(attr(delete.response(terms(as.formula(formula))), "factors"))
      } else {
        dVar <- dimVar
      }
    }
  }
  
  
  if (preAggregate) {
    cat("[preAggregate ", dim(data)[1], "*", dim(data)[2], "->", sep = "")
    flush.console()
    if(length(c(freqVar, rKeyVar))){
      if(!length(freqVar)){  # simpler code by adding 1s, but then the entire data.frame is copied into memory
        freqVar_ <- "f_Re_qVa_r"
        data_freqVar <- aggregate(list(f_Re_qVa_r = data[[dVar[1]]]), data[, dVar, drop = FALSE], length)[[freqVar_]]
      } else {
        data_freqVar <- NULL
      }
      data <- aggregate(data[, c(freqVar, rKeyVar), drop = FALSE], data[, dVar, drop = FALSE], FUNaggregate)
      if(!is.null(data_freqVar)){
        freqVar <- freqVar_
        data[[freqVar]] <- data_freqVar
      }
    } else {
      data <- aggregate(list(f_Re_qVa_r = data[[dVar[1]]]), data[, dVar, drop = FALSE], length)
      freqVar <- "f_Re_qVa_r" 
    }
    cat(dim(data)[1], "*", dim(data)[2], "]", sep = "")
    flush.console()
    if (innerReturn) {
      if (freqVar == "f_Re_qVa_r") {
        if (!("freq" %in% names_data)) {
          names(data)[names(data) == freqVar] <- "freq"
          freqVar <- "freq"
        }
      }
      inner <- list(inner = data)
    }  
  } else {
    if (innerReturn) {
      inner <- list(inner = data[, c(dVar, freqVar, rKeyVar), drop = FALSE])
    }
  }
  
  if (is.numeric(innerReturn)) {
    if (innerReturn == 1) {
      return(inner$inner)
    }
  }
  
  if (is.null(rKeyVar)) {
    if (!is.null(rndSeed)) {
      if (!exists(".Random.seed")) 
        if (runif(1) < 0) 
          stop("Now seed exists")
      exitSeed <- .Random.seed
      on.exit(.Random.seed <<- exitSeed)
      set.seed(rndSeed)
    }
    rkeys <- runif(NROW(data))
    rKeyVar <- "rKeyVar"
    bitkey <- truncate_int_by_bit(rkeys * 1e7)
  } else {
    rkeys <- data[, rKeyVar]
  }
  
  
  if (is.null(x)) {
    if (!is.null(crossTable)) {
      warning("crossTable in input ignored when input x is NULL")
    }
    crossTable <- TRUE
  }
  
  cat("[ModelMatrix")
  flush.console()
  
  
  mm <- ModelMatrix(data = data, hierarchies = hierarchies, formula = formula, crossTable = crossTable, modelMatrix = x, total = total, dimVar = dimVar)
  
  if (xReturn) {
    x <- list(x = mm$modelMatrix)
  } else {
    x <- vector("list", 0)
  }
  
  cat("]")
  flush.console()
  
  cat("[aggregate rkeys")
  flush.console()
  # rKey <- Matrix::crossprod(mm$modelMatrix, rkeys)[, 1, drop = TRUE] %%1 
  # More general calculation with DummyApply and FUNaggregate
  pop.key <- Reduce(bitwXor, bitkey)
  rKey <- DummyApply(mm$modelMatrix, rkeys, FUNaggregate)
  cellkey <- DummyApply(mm$modelMatrix, as.vector(bitkey),
                       function(x) aggregate_bitkeys(x, pop.key = pop.key))
  cat("]")
  flush.console()
  
  
  cat("[Aggregates.")
  flush.console()
  
  if (length(freqVar)) {
    original <- Matrix::crossprod(mm$modelMatrix, data[, freqVar])[, 1, drop = TRUE]
  } else {
    data <- cbind(as.data.frame(mm$crossTable, stringsAsFactors = FALSE), r_Ke_yVa_r = rKey)
    names(data)[NCOL(data)] <- rKeyVar
    cat("]\n")
    flush.console()
    rownames(data) <- NULL
    if (xReturn | innerReturn) {
      return(c(list(publish = data), inner, x))
    }
    return(data)
  }
  
  cat(".perturb.")
  flush.console()
  
  if (is.character(rKey)) {
    bitkey <- matrix(rKey, ncol = 1, dimnames = list(NULL, rKeyVar))
    rKey <- (as.numeric(rKey) + 0.5)/256
    rKeyVar <- paste0("unif_", rKeyVar)
  } else {
    # bitkey <- matrix("0", nrow = length(rKey), ncol = 0)
  }
  if (usePTable) {
    pMatrix <- Pmatrix(D = D, V = V, js = js, pstay = pstay)
    perturbed <- Pconvert(original, pMatrix, rKey)
    prt <- NULL
  }
  else {
    mm <<- mm
    original <<- original
    probmat <-  generate_prob_matrix(
      D = D,
      step = js,
      noisefunction = noisefunction,
      width = 5,
      percnoise = relativeNoise,
      ...
    )
    lutable <- generate_lookup_table(probmat, 256, seed = rndSeed, ...)
    lutable <<- lutable
    # print(prt)
    if (!relativeNoise) {
      prt <- perturb(keys = cellkey,
               values = original, 
               ptable = lutable,
               ddc.function = ddc.function)
      perturbed <- original + prt
    }
    else {
      ddc <- ddc.function(data = data, hierarchies = hierarchies, formula = formula, crossTable = mm$crossTable, x = mm$modelMatrix, total = total, dimVar = dimVar, freqVar = freqVar, ...)
      topk <- MaxContribution(x = mm$modelMatrix, 
                              y = data[[freqVar]],
                              n = k,
                              index = TRUE)

      relnoise <- topk
      for (i in seq_len(nrow(topk))){
        relnoise[i,] <-
          retrieve_noise(prob_table = lutable, 
                         keys = topk[i,], 
                         ddc = rep(ddc[i], k))
      }
      flex <- flex.function(original)
      if (length(m) != k)
        stop("m must have length k.")
      prt <- m * flex * relnoise * apply(topk, 2, function(x) data[x, freqVar])
      prt[is.na(prt)] <- 0
      prt <- rowSums(prt)
       perturbed <- original + prt
    }
    rKey <- cellkey
  }
  
  data <- cbind(as.data.frame(mm$crossTable, stringsAsFactors = FALSE), original = original, key = rKey, perturbation = prt, relnoise = relnoise, flex = flex, perturbed = perturbed, ddc = ddc)#, perturbed = perturbed, r_Ke_yVa_r = rKey)
  cat("]\n")
  flush.console()
  # names(data)[NCOL(data)] <- rKeyVar
  rownames(data) <- NULL
  if (xReturn | innerReturn) {
    return(c(list(publish = data), inner, x))
  }
  data
}




FUNaggregate <- function(x){ 
  if(is.character(x)){ 
    stop("Character input is not implemented yet.")
  }
  if(!length(x))
    return(sum(x))   ### OBS:  No rKey -> 0
  if(x[1]>0 & x[1]<1)
    return(sum(x) %%1)
  sum(x)
}


# temporary function as replacement for SSBtoolsData("my_km2") available in next SSBtools version
my_km2 <- function(){ # my_km² not allowed, Portable packages must use only ASCII characters in their R code,
  data.frame(Square1000m  = c(rep("my_km",10), rep("another_km",8)),
             Square250m   = c(rep("500_000",3), rep("750_250",4), rep("750_500",3), rep("another_500_000",4), rep("another_750_250",4)),
             Municipality = c(rep("Oslo",3), rep("Nittedal",6), rep("Oslo",9)),
             Age = c("15_to_65", "15_to_65", "under_15", "15_to_65", "15_to_65", "under_15", "under_15", "65_and_over", "65_and_over", "15_to_65", 
                     "15_to_65", "15_to_65", "under_15", "under_15", "15_to_65", "15_to_65", "65_and_over", "65_and_over"),
             Sex = c("female", "male", "male", "female", "male", "female", "male", "female", "male", "female", "female", "male", "female", "male", 
                     "female", "male", "female", "male"),
             freq = c(3, 2, 1, 2, 2, 1, 1, 1, 1, 1, 26, 21, 31, 34, 2, 1, 10, 13))
}















