

#' Function for perturbing numerical values using cell key with flex functions
#'
#' @param num vector of numerical values
#' @param pTable perturbation table, generated by pTab;e
#' @param contributors matrix  containing k top contributors,
#' nrow(contributors) = length(x), ncol(contributors) = k.
#' @param rkeys vector of record keys
#' @inheritParams flex_functions
#' @return
#' @export
#'
#' @examples
Pconvert_num <-
  function(num,
           pTable,
           contributors,
           rkeys = matrix(runif(ncol(contributors) * nrow(contributors)), ncol = ncol(contributors)),
           s0 = 0.05,
           s1 = 0.25,
           zf = 10,
           q = 3,
           flex_constant = FALSE) {
    m <-
      apply(contributors, 2, function(x)
        flex_function(x, s0, s1, zf, q, flex_constant))
    x_delta <- contributors * m
    x_delta <- apply(x_delta, 2, function(x) {
      x[x > num] <- num[x > num]
      x
    })
    a <- apply(x_delta, 2, function(x)
      num / x)
    # }
    # else {
    #   x_delta <- contributors * m
    #   x_delta[x_delta > num] <- num[x_delta > num]
    #   a <- num / x_delta
    # }
    nrow_a <- nrow(a)
    a <- as.vector(a)
    
    rkeys <- as.vector(rkeys)
    D <- max(abs(pTable[, v]))
    a[a > D] <- D
    # here we set a0 to 1, a1 to D
    lambda <- (a - 1) / (D - 1)
    # lookup using rolling join
    pTable$Roll <- pTable$p_int_lb
    
    rkey <- data.table(Roll = rkeys)
    v_za0 <- pTable[i == 1, ][rkey, v, on = "Roll", roll = TRUE]
    v_za1 <- pTable[i == D, ][rkey, v, on = "Roll", roll = TRUE]
    v_za <- matrix(((1 - lambda) * v_za0 + lambda * v_za1), nrow = nrow_a)
    v_za <<- v_za
     noise <- x_delta * v_za
    num + rowSums(noise)
  }


#' Flex function as described in Giessing and Tent 2019
#'
#' @param x 
#' @param s0 sigma_0 in flex function definition
#' @param s1 sigma_1 in flex function definition
#' @param zf flex point in flex function definition
#' @param q parameter q in flex function definition
#' @param constant logical value, default FALSE, if TRUE, returns s0.
#'
#' @return numerical value
#' @export
#'
flex_function <- function(x, s0, s1, zf, q, constant = FALSE) {
  if (constant)
    return(rep(s0, length(x)))
  res <- s0 * (1 + (s1*x - s0 * zf) / (s0 * zf) * (2*zf/(zf + x))^q)
  res[x < zf] <- s1
  res
}
