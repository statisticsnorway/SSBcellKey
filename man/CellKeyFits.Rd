% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CellKeyFits.R
\name{CellKeyFits}
\alias{CellKeyFits}
\title{Cell-key perturbation with post-processing to expected frequencies}
\usage{
CellKeyFits(
  data,
  freqVar = NULL,
  rKeyVar = NULL,
  hierarchies = NULL,
  formula = NULL,
  dimVar = NULL,
  preAggregate = is.null(freqVar),
  xReturn = FALSE,
  extend0 = TRUE,
  limit = 1e-10,
  viaQR = FALSE,
  iter = 1000,
  eps = 0.01,
  tol = 1e-13,
  reduceBy0 = TRUE,
  reduceByColSums = TRUE,
  reduceByLeverage = FALSE,
  ...
)
}
\arguments{
\item{data}{data frame (inner cells)}

\item{freqVar}{Variable holding counts}

\item{rKeyVar}{Variable holding keys}

\item{hierarchies}{List of hierarchies}

\item{formula}{Model formula}

\item{dimVar}{Dimensional variables}

\item{preAggregate}{Aggregation}

\item{xReturn}{Dummy matrix in output when \code{TRUE}. To return crossTable as well, use \code{xReturn = 2}.}

\item{extend0}{Data is automatically extended by \code{Extend0} when \code{TRUE}. Can also be specified as a list meaning parameter \code{varGroups} to \code{Extend0}.}

\item{limit}{\code{LSfitNonNeg} parameter}

\item{viaQR}{\code{LSfitNonNeg} parameter}

\item{iter}{\code{Mipf} parameter}

\item{eps}{\code{Mipf} parameter}

\item{tol}{\code{Mipf} parameter}

\item{reduceBy0}{\code{Mipf} parameter}

\item{reduceByColSums}{\code{Mipf} parameter}

\item{reduceByLeverage}{\code{Mipf} parameter}

\item{...}{Further parameters to \code{\link{CellKey}}. Relevant parameters: \code{total}, \code{rndSeed} and parameters to \code{\link{pt_create_pParams}}}
}
\value{
A two-element list:
\item{inner}{Data frame corresponding to input data with expected frequencies (\code{ipFit}).}
\item{publish}{Data frame with output from \code{\link{CellKey}} extended with least squares fits (\code{lsFit}) and aggregated expected frequencies (\code{ipFit}).}
}
\description{
The counts perturbed by \code{\link{CellKey}}
are additivity restored by least squares with a non-negativity modification using \code{\link{LSfitNonNeg}}.
Thereafter expected inner cell frequencies are generated by iterative proportional fitting using \code{\link{Mipf}}.
To ensure that empty cells missing in input data are included in the fitting process, the data is first extended using \code{\link{Extend0}}.
}
\details{
The six first parameters is documented in more detail in \code{\link{CellKey}}.
If iterative proportional fitting succeeds, the maximum difference between \code{lsFit} and \code{ipFit} is less than input parameter \code{eps}.
}
\examples{
z <- data.frame(geo  = c("Iceland", "Portugal", "Spain"), 
                eu = c("nonEU", "EU", "EU"),
                year = rep(c("2018","2019"), each = 3),
                freq = c(2,3,7,1,5,6), stringsAsFactors = FALSE)
z4 <- z[-c(1:2), ]

CellKeyFits(z4, "freq", formula = ~eu * year + geo, extend0 = FALSE)
CellKeyFits(z4, "freq", formula = ~eu * year + geo)
set.seed(123)
z4$keys <- runif(4)
CellKeyFits(z4, "freq", "keys", formula = ~eu * year + geo)                 

my_km2 <- SSBtools::SSBtoolsData("my_km2")

# Default automatic extension (extend0 = TRUE)
CellKeyFits(my_km2, "freq", formula = ~(Sex + Age) * Municipality * Square1000m + Square250m)

# Manual specification to avoid Nittedal combined with another_km
CellKeyFits(my_km2, "freq", formula = ~(Sex + Age) * Municipality * Square1000m + Square250m, 
            extend0 = list(c("Sex", "Age"), c("Municipality", "Square1000m", "Square250m")))
}
